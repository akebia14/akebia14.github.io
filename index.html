<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>1〜25 タップゲーム</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; padding: 16px; max-width: 560px; margin: 0 auto; }
    h1 { font-size: 20px; margin: 0 0 10px; }
    .ver { font-size: 12px; color:#666; margin: 0 0 12px; }

    .bar { display: grid; grid-template-columns: 1fr 1fr; gap: 8px 12px; margin-bottom: 12px; }
    .stat { padding: 10px 12px; border: 1px solid #ddd; border-radius: 10px; background: #fafafa; font-size: 14px; }
    .stat b { font-size: 18px; }

    .controls { display: flex; gap: 8px; margin: 12px 0 16px; }
    button.ctrl { padding: 10px 14px; font-size: 16px; border-radius: 10px; border: 1px solid #ddd; background: #fff; }

    .grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; min-height: 260px; user-select: none; -webkit-user-select: none; }
    .cell { aspect-ratio: 1 / 1; border-radius: 12px; border: 1px solid #ddd; background: #fff; font-size: 18px; font-weight: 700; }
    .cell.correct { background: #e9f7ef; border-color: #b7e4c7; color: #1b4332; }
    .cell.wrong { background: #fff0f0; border-color: #ffb3b3; color: #7a0000; }
    .cell:disabled { opacity: 0.6; }

    .gaugeWrap { height:10px; border:1px solid #ddd; border-radius:999px; overflow:hidden; background:#fff; margin-top:6px; }
    .gaugeBar { height:100%; width:0%; background:#4caf50; }

    .note { font-size: 12px; color: #666; margin-top: 12px; line-height: 1.6; }
    .note b { color:#333; }
  </style>
</head>
<body>
  <h1>1〜25 タップゲーム（コンボ・合算スコア）</h1>
  <div class="ver">v20251230-combo-score-1</div>

  <div class="bar">
    <div class="stat">残り時間：<b id="time">60</b> 秒</div>
    <div class="stat">次に押す数字：<b id="next">1</b></div>

    <div class="stat">ポイント：<b id="points">0</b></div>
    <div class="stat">コンボ：<b id="combo">0</b></div>

    <div class="stat">ミス：<b id="miss">0</b> 回</div>
    <div class="stat">ベスト（合算）：<b id="best">—</b></div>

    <div class="stat" style="grid-column: 1 / -1;">
      コンボ猶予（2秒）
      <div class="gaugeWrap"><div id="comboGauge" class="gaugeBar"></div></div>
    </div>
  </div>

  <div class="controls">
    <button class="ctrl" id="startBtn">開始</button>
    <button class="ctrl" id="resetBtn">リセット</button>
  </div>

  <div class="grid" id="grid" aria-label="number grid"></div>

  <p class="note">
    ルール：1→25を順にタップ。<b>ミスで −5秒</b> & <b>ポイント −1</b>。<br>
    コンボ：前回の正解から<b>2秒以内</b>に次の正解で成立。<br>
    クリア時スコア：<b>（ポイント）＋（残り秒）</b>。ベストは合算スコアを保存します。
  </p>

  <script>
    // ===== 仕様 =====
    const GAME_SECONDS = 60;
    const PENALTY_SECONDS = 5;

    const COMBO_WINDOW_MS = 2000;

    // ベストは「合算スコア（ポイント+残り秒）」で保存
    const BEST_KEY = "best_total_score_points_plus_remaining";

    // ===== 状態 =====
    let remaining = GAME_SECONDS;
    let expected = 1;
    let miss = 0;

    let points = 0;          // コンボ加点・ミス減点・（クリア時）残り秒加点
    let combo = 0;           // 高速遷移コンボ回数（2回目の正解で1になる）
    let lastCorrectAt = null;

    let timerId = null;
    let running = false;

    let gaugeRafId = null;

    // ===== DOM =====
    const timeEl = document.getElementById("time");
    const nextEl = document.getElementById("next");
    const missEl = document.getElementById("miss");
    const pointsEl = document.getElementById("points");
    const comboEl = document.getElementById("combo");
    const bestEl = document.getElementById("best");
    const comboGaugeEl = document.getElementById("comboGauge");

    const gridEl = document.getElementById("grid");
    const startBtn = document.getElementById("startBtn");
    const resetBtn = document.getElementById("resetBtn");

    function render() {
      timeEl.textContent = String(remaining);
      nextEl.textContent = String(expected);
      missEl.textContent = String(miss);
      pointsEl.textContent = String(points);
      comboEl.textContent = String(combo);
    }

    function getBest() {
      const v = Number(localStorage.getItem(BEST_KEY));
      return Number.isFinite(v) ? v : null;
    }

    function setBest(v) {
      localStorage.setItem(BEST_KEY, String(v));
      bestEl.textContent = String(v);
    }

    // ===== シャッフル =====
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function clearGrid() {
      gridEl.innerHTML = "";
    }

    // ===== コンボゲージ =====
    function stopComboGauge() {
      if (gaugeRafId !== null) cancelAnimationFrame(gaugeRafId);
      gaugeRafId = null;
      comboGaugeEl.style.width = "0%";
    }

    function startComboGauge() {
      if (gaugeRafId !== null) return;

      const loop = () => {
        if (!running || lastCorrectAt === null) {
          stopComboGauge();
          return;
        }

        const now = performance.now();
        const remainMs = Math.max(0, COMBO_WINDOW_MS - (now - lastCorrectAt));
        const pct = (remainMs / COMBO_WINDOW_MS) * 100;

        comboGaugeEl.style.width = pct.toFixed(2) + "%";

        if (remainMs === 0) {
          combo = 0;
          render();
          stopComboGauge();
          return;
        }

        gaugeRafId = requestAnimationFrame(loop);
      };

      gaugeRafId = requestAnimationFrame(loop);
    }

    // ===== 盤面生成 =====
    function buildGrid() {
      clearGrid();

      const nums = shuffle(Array.from({ length: 25 }, (_, i) => i + 1));

      for (const n of nums) {
        const btn = document.createElement("button");
        btn.className = "cell";
        btn.type = "button";
        btn.textContent = String(n);

        btn.addEventListener("click", () => {
          if (!running) return;

          if (n === expected) {
            // 正解
            btn.classList.add("correct");
            btn.disabled = true;

            // コンボ判定（「前回正解→今回正解」間が2秒以内）
            const now = performance.now();

            if (lastCorrectAt !== null) {
              const delta = now - lastCorrectAt;

              if (delta <= COMBO_WINDOW_MS) {
                combo += 1;

                // コンボ加点
                if (combo >= 5) points += 5;
                else if (combo >= 3) points += 2;
                else points += 1;

              } else {
                combo = 0; // 2秒超えで途切れ
              }
            } else {
              combo = 0; // 1回目の正解は起点
            }

            lastCorrectAt = now;
            startComboGauge();

            expected += 1;
            render();

            if (expected === 26) finish(); // 25まで到達
          } else {
            // ミス
            miss += 1;

            // 時間ペナルティ
            remaining = Math.max(0, remaining - PENALTY_SECONDS);

            // ポイント減点（あなたの仕様どおり）
            points -= 1;

            // コンボは途切れる
            combo = 0;
            lastCorrectAt = null;
            stopComboGauge();

            render();

            // 振動（動作は端末/ブラウザ仕様に依存）
            if (navigator.vibrate) navigator.vibrate(30);

            btn.classList.add("wrong");
            setTimeout(() => btn.classList.remove("wrong"), 180);

            if (remaining === 0) gameOver();
          }
        });

        gridEl.appendChild(btn);
      }
    }

    // ===== タイマー =====
    function tick() {
      remaining -= 1;
      if (remaining <= 0) {
        remaining = 0;
        render();
        gameOver();
        return;
      }
      render();
    }

    function startGame() {
      if (running) return;

      // 開始時に盤面生成
      buildGrid();

      running = true;
      startBtn.disabled = true;

      // 初回開始時はコンボ起点なし
      combo = 0;
      lastCorrectAt = null;
      stopComboGauge();

      timerId = setInterval(tick, 1000);
      render();
    }

    function stopTimer() {
      if (timerId !== null) clearInterval(timerId);
      timerId = null;
      running = false;
      startBtn.disabled = false;
    }

    function finish() {
      // クリア時：残り秒をそのままポイントに加算（あなたの仕様）
      points += remaining;

      stopTimer();
      combo = 0;
      lastCorrectAt = null;
      stopComboGauge();

      // 合算スコア = points（＝コンボ/減点を含み、ここで残り秒も加算済み）
      const totalScore = points;

      const best = getBest();
      if (best === null || totalScore > best) setBest(totalScore);

      render();
      alert("クリア！ 合算スコア " + totalScore);
    }

    function gameOver() {
      stopTimer();
      combo = 0;
      lastCorrectAt = null;
      stopComboGauge();

      render();
      alert("時間切れ（合算スコアはクリア時のみ確定）");
    }

    function resetGame() {
      stopTimer();

      remaining = GAME_SECONDS;
      expected = 1;
      miss = 0;

      points = 0;
      combo = 0;
      lastCorrectAt = null;
      stopComboGauge();

      clearGrid();
      render();

      const best = getBest();
      bestEl.textContent = best === null ? "—" : String(best);
    }

    startBtn.addEventListener("click", startGame);
    resetBtn.addEventListener("click", resetGame);

    // init
    resetGame();
  </script>
</body>
</html>
